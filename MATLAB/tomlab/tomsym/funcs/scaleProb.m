function Prob = scaleProb(Prob, xScale, cScale, aScale, fScale)
% scaleProb - Set the scales for a scaleable tomSym problem
%
% Prob = scaleProb(Prob, xScale, cScale, aScale, fScale)
% changes the scaling used in Prob so that the decision variables are
% scaled by xScale, the nonlinear constraints are scaled by cScale, the
% linear constraints are scaled by aScale, and the objective is scaled by
% fScale.
%
% This allwos manual setting of all scaling parameters, which may be
% necessary to obtain convergence in cases where autoScaleProb fails.
%
% The decsision variables seen by the solver will be multiplied by xScale,
% which means that larger values for xScale will result in a smaller values
% used by the solver. In many cases, setting xScale equal to the upper
% bound for x will be a good scaling, as that will make the upper bound, as
% seen by the solver, equal one for all descision variables.
%
% xScale should be a vector of length equal to the number of decision
% variables.
%
% The function outputs will be multiplied by cScale aScale and fScale
% respectively. This means that larger values for these scales will result
% in larger values seen by the solver.
%
% cScale should be a vector of length equal to the number of nonlinear
% constraints, aScale should be a vector of lenght equal to the number of
% linear constraints, and fScale should be a scalar. 
%
% Entering an empty matrix for any of xScale cScale or aScale will leave
% that scaling unchanged.
%
% To remove a scaling, set the corresponding scale factor to 1.
% (Note: The autogenerated code will still contain a multiplication by the
% scale factors. Re-generating the Prob struct with scaling disabled will
% result in slightly faster code.)
%
% See also: autoScaleProb

% Per Rutquist, Tomlab Optimization Inc, E-mail: tomlab@tomopt.com
% Copyright (c) 2009 by Tomlab Optimization Inc.
% Last modified 2009-12-23 by rutquist for TOMLAB release 7.7

if nargin < 2
    xScale = [];
end
if nargin < 3
    cScale = [];
end
if nargin < 4
    aScale = [];
end
if nargin < 5
    fScale = [];
end

if ~isfield(Prob,'tomSym')
    error('The Prob struct does not seem to originate from a tomSym problem.');
end

if ~isfield(Prob.tomSym,'xScale')
    error('The problem does not seem to use scaling. (Try setting options.scale)');
end

if ~isempty(xScale);
    xScale = abs(xScale);
    if any(xScale==0) || any(isinf(xScale)) || any(isnan(xScale))
        error('Illegal scale factor for x');
    end
    if numel(xScale)==1
        xScale = repmat(xScale,size(Prob.tomSym.xScale));
    end
    xr = xScale(:)./Prob.tomSym.xScale;
    Prob.tomSym.xScale = xScale(:);
    if ~isempty(Prob.A)
        Prob.A = scalecolumns(xr,Prob.A);
    end
    Prob.x_0 = Prob.x_0./xr; 
    Prob.x_L = Prob.x_L./xr; 
    Prob.x_U = Prob.x_U./xr;
    if ~isempty(Prob.x_min)
        Prob.x_min = Prob.x_min./xr;
        Prob.x_max = Prob.x_max./xr;
    end
    if ~isempty(Prob.QP)
        if ~isempty(Prob.QP.c)
            Prob.QP.c = Prob.QP.c.*xr;
        end
        if isfield(Prob.QP,'F') && ~isempty(Prob.QP.F)
            Prob.QP.F = Prob.QP.F.*(xr*xr');
        end
    end
    if isfield(Prob.PENOPT,'SDP')
        for k = 1:length(Prob.PENOPT.SDP)
            if isfield(Prob.PENOPT.SDP(k),'Qidx')
                for i = 1:length(Prob.PENOPT.SDP(k).Qidx)
                    if Prob.PENOPT.SDP(k).Qidx(i) ~= 0
                        Prob.PENOPT.SDP(k).Q{i} = xr(Prob.PENOPT.SDP(k).Qidx(i))*Prob.PENOPT.SDP(k).Q{i};
                    end
                end
            end
            if isfield(Prob.PENOPT.SDP(k),'Kidx')
                for i = 1:size(Prob.PENOPT.SDP(k).Kidx,1)
                    for d=1:2
                        Prob.PENOPT.SDP(k).K{i} = xr(Prob.PENOPT.SDP(k).Kidx(i,d))*Prob.PENOPT.SDP(k).K{i};
                    end
                end
            end
        end
    end
    if isfield(Prob.optParam,'eps_x')
        % Change tolerances according to the xScale that gives the least
        % amount of change.
        if all(xr<1)
            Prob.optParam.eps_x = Prob.optParam.eps_x./max(xr);
        elseif all(xr>1)
            Prob.optParam.eps_x = Prob.optParam.eps_x./min(xr);
        end
    end
end

if ~isempty(cScale);
    cScale = abs(cScale);
    if any(cScale==0) || any(isinf(cScale)) || any(isnan(cScale))
        error('Illegal scale factor for c');
    end
    if numel(cScale)==1
        cScale = repmat(cScale,size(Prob.tomSym.cScale));
    end
    cr = cScale(:)./Prob.tomSym.cScale;
    Prob.tomSym.cScale = cScale(:);
    Prob.c_L = Prob.c_L.*cr;
    Prob.c_U = Prob.c_U.*cr;
end

if ~isempty(aScale);
    aScale = abs(aScale);
    if any(aScale==0) || any(isinf(aScale)) || any(isnan(aScale))
        error('Illegal scale factor for a');
    end
    if numel(aScale)==1
        aScale = repmat(aScale,size(Prob.tomSym.aScale));
    end
    ar = aScale(:)./Prob.tomSym.aScale(:);
    Prob.tomSym.aScale = aScale(:);
    Prob.A = scalerows(ar,Prob.A);
    Prob.b_L = Prob.b_L.*ar;
    Prob.b_U = Prob.b_U.*ar;
end

if ~isempty(fScale);
    fScale = abs(fScale);
    if numel(fScale)~=1
        error('fScale should be a scalar');
    end
    if fScale==0 || isinf(fScale) || isnan(fScale)
        error('Illegal scale factor for f');
    end
    fr = fScale./Prob.tomSym.fScale;
    Prob.tomSym.fScale = fScale;
    if ~isempty(Prob.QP)
        if isfield(Prob.QP,'c') && ~isempty(Prob.QP.c)
            Prob.QP.c = Prob.QP.c.*fr';
        end
        if isfield(Prob.QP,'F') && ~isempty(Prob.QP.F)
            Prob.QP.F = Prob.QP.F.*fr;
        end
    end
    if isfield(Prob.optParam,'eps_f')
        Prob.optParam.eps_f = Prob.optParam.*fr;
    end

end

