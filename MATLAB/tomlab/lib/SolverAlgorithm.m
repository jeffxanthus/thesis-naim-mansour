% SolverAlgorithm returns a header and a menu for a particular solver
%
% function [Header, Menu] = SolverAlgorithm(Solver,Alg)
% 
% INPUT: 
% Solver      Name of solver
%
% OUTPUT: 
% Header      The header
% Menu        A string matrix with the different menu options

% Kenneth Holmstrom, Tomlab Optimization Inc, E-mail: tomlab@tomopt.com
% Copyright (c) 2000-2005 by Tomlab Optimization Inc., $Release: 5.2.0$
% Written Sept 26, 2000.  Last modified Feb 12, 2006.

function [Header, Menu] = SolverAlgorithm(Solver)

Header=[]; Menu=[];

switch deblank(Solver)
   case {'ucSolve'}
      Header = 'Algorithm';
      Menu = str2mat( ...
         'ucSolve default algorithm' ...
        ,'Newton' ...
        ,'Quasi-Newton BFGS' ...
        ,'Quasi-Newton BFGS (Hessian)' ...
        ,'Quasi-Newton DFP' ...
        ,'Quasi-Newton DFP (Hessian)' ...
        ,'Fletcher-Reeves Conj Grad' ...
        ,'Polak-Ribiere Conj Grad' ...
        ,'Fletcher Conj Descent' ...
      );
      
   %case {'qpSolve'}
   case {'conSolve'}
      Header = 'Algorithm';
      Menu = str2mat( ...
         'conSolve default algorithm' ...
        ,'Aug.Lagrangian using Hessian' ...
        ,'Aug.Lagrangian quasi-Newton BFGS' ...
        ,'Han-Powell using Hessian' ...
        ,'Han-Powell quasi-Newton BFGS' ...
      );
   case {'nlpSolve'}
      Header = 'Algorithm';
      Menu = str2mat( ...
         'Filter SQP using Hessian' ...
        ,'Filter SQP quasi-Newton BFGS' ...
      );
   case {'sTrustr'}
      Header = 'Algorithm';
      Menu = str2mat( ...
         'Using second derivatives' ...
        ,'Quasi-Newton BFGS' ...
        ,'Quasi-Newton DFP' ...
      );
   case {'clsSolve'}
      Header = 'Algorithm';
      Menu = str2mat(...
         'clsSolve default algorithm' ...
        ,'Fletcher-Xu Hybrid method' ...
        ,'Al-Baali-Fletcher Hyb.meth.' ...
        ,'Huschens method' ...
        ,'Gauss Newton' ...
      );
   case {'mipSolve'}
      Header = 'Node Selection Method';
      Menu = str2mat(...
         'Depth First' ...
        ,'Breadth First' ...
        ,'Depth First. Then Breadth.' ...
      );
   case {'lpSimplex'}
      Header = 'Variable selection';
      Menu = str2mat(...
         'Simplex, Minimum cost rule' ...
        ,'Simplex, Blands rule' ...
        ,'Simplex, MC rule (Dantzig)' ...
      );

   %case {'glbSolve'}
   %case {'glbFast'}
   %case {'glcSolve'}
   %case {'glcFast'}
   %case {'glcCluster'}
   %case {'rbfSolve'}
   %case {'arbfmip'}
   %case {'ego'}
   %case {'DualSolve'}
   %case {'infSolve'}
   %case {'cutPlane'}
   %case {'LPOPT','QPOPT','MINOS''NPSOL','NLSSOL','SNOPT','SQOPT'}

   %case {'Xpress-MP'}
   %case {'CPLEX'}
   %case {'bqpd'}
   %case {'MIQPbb'}
   %case {'PENSDP'}
   %case {'PENBMI'}
   %case {'PDCO'}
   %case {'PDSCO'}
   %case {'filterSQP'}
   %case {'MINLPbb'}

   %case {'fmincon'}
   %case {'fminsearch'}
   %case {'fminunc'}
   %case {'linprog'}
   %case {'lsqcurvefit'}
   %case {'lsqlin'}
   %case {'lsqnonlin'}
   %case {'lsqnonneg'}
   %case {'quadprog'}
   %case {'constr'}
   %case {'fmins'}
   %case {'fminu'}
   %case {'lp'}
   case {'qp'}
      % OPTIM TB qp.m with option negdef=1 or not
      Header = 'Algorithm';
      Menu = str2mat( ...
         'Standard method' ...
        ,'Negative definite method' ...
      );
   %case {'leastsq'}
   %case {'SQOPT'}
   %case {'qld'}
   %case {'lssol'}
end

% Use the following, or???
%,'Affine Scaling Karmarkar' ...
%,'lpsimp2, Minimum cost rule' ...
%,'lpsimp2, Blands rule' ...
%,'lpsimp2, MC rule (Dantzig)' ...

% MODIFICATION LOG
%
% 000926 hkh  Routine written
% 010408 hkh  Add mipSolve
% 020701 hkh  Add 6 new solvers
% 020723 hkh  Add PDCO, PDSCO, PENBMI
