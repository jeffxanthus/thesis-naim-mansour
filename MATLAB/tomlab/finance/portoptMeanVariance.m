% TOMLAB - Financial Optimization, Mean Variance.
%
% Build a portfolio whose risk is as small as possible, but subject to a
% pre-determined minimal return. The problem can be formulated as an
% optimization problem called the mean-variance model (MV).
%
%     Minimize     sum{i,j} Q(i,j)w(i)w(j), where i,j are assets.
%
%     Subject to       sum(w(j)) = 1, where j are assets.
%                      sum(r_hat(j)w(j)) >= r_min, where j are assets.
%                      w(j)_min <= w(j) <= w(j)_max, where j are assets.
%
% w(j) corresponds to an unknown allocation for asset j, r_hat(j) is the
% observed mean return of asset j, r_min is the minimum accepted mean
% return, and w(j)_min, w(j)_max are the minimum and maximum allowable
% weights. Q(i,j) is the covariance matrix of returns, given by
%
%                      Q = 1/(n-1)*(R-R_hat)'*(R-Rhat)
%
% where R is a return-matrix whose (t,j) element is the return for asset j
% observed in period t and R_hat is a matrix whose rows are replicates of
% the vector r_hat.
%
% If there are no constraints on the weights, so w(j)_min = -inf and
% w(j)_max = inf, then an explicit analytic solution can be obtained. If
% the weights are constrained to lie in a pre-specified region, e.g. only
% positive weights are allowed (w(j)_min = 0), then the solution must be
% obtained by numerical methods.
%
%
% There are two possible internal models for this problem:
%
% First option (default):
%
%      Minimize        0.5x'Qx + cx
% 
%      Subject to     b_L <= Ax <= b_U
%                     x_L <= x  <= x_U
%
% where Q is the covariance matrix of the returns.
%
% An alternative formualtion of an optimization problem can lead to
% improvements in efficiency and stability. If the matrix of returns R has
% many more columns than rows in the Mean-Variance problem, a factorization
% of the covariance matrix gives an efficient means of computing the
% objective. This formulation is the second option.
%
% Second option:
%  
%      Minimize            z'z
% 
%      Subject to       z = R_wave*w
%                       sum(w(j)) = 1
%                       sum(r_hat(j)*w(j)) >= r_min
%                       w(j)_min <= w(j) <= w(j)_max
%
% where R_wave = (R - R_hat). This problem is reformulated using the 
% following transformation:
%
%      x = [w; z];    Q = [0 0; 0 I];   x_L = [w_min; -inf];
%      x_U = [w_max; inf];  A = [R_wave -I; R_hat' 0'; 1' o'];
%      
%
% -----------------------------------------------------
%
%
% Syntax of portoptMeanVariance:
%
% function [weights, Result] = portoptMeanVariance(R, w_min, w_max, r_min, solver,...
%                   dense, PriLev, Name, model);
%
% INPUTS (No parameters needed, test case if no)
%
% R:           Matrix n x m. Default - random matrix 200x100.
%
% w_min:       Lower bound for assets. Default - 0.
% w_max:       Upper bound for assets. Defaul - inf.
%
% r_min:       Minimum accepted return. Default 0.001.
%
% solver:      Solver to use. Default decided by GetSolver('qp').
% dense:       1 means dense solver, 0 means sparse solver. Default depends
%              on matrix density. model = 2 is always sparse.
%
% PriLev:      Print-level in the optimization routine. Default 1.
%
% Name:        Name of problem. Default 'FIN OPT'.
%
% model:       Model used to formulate the problem. Default 1. 2 should be 
%              used if there are many assets compared to periods.
%
% OUTPUTS
%
% weights:     Weights for each asset.
%
% Result:      The standard result structure generated by TOMLAB.

% Marcus Edvall, Tomlab Optimization Inc., E-mail: tomlab@tomopt.com.
% Copyright (c) 2004-2005 by Tomlab Optimization Inc., Sweden. $Release: 4.6.0$
% Written Oct 16, 2004. Last modified Jan 17, 2005.

function [weights, Result] = portoptMeanVariance(R, w_min, w_max, r_min, solver,...
    dense, PriLev, Name, model)

if nargin < 9
    model=[];
    if nargin < 8
        Name=[];
        if nargin < 7
            PriLev=[];
            if nargin < 6
                dense=[];
                if nargin < 5
                    solver=[];
                    if nargin < 4
                        r_min=[];
                        if nargin < 3
                            w_max=[];
                            if nargin < 2
                                w_min=[];
                                if nargin < 1
                                    R=[];
end, end, end, end, end, end, end, end, end

if isempty(R)
    assets = 100;
    periods = 200;
    randn('state',0);             % RESET RANDOM NUMBER GENRATOR
    R = normrnd(0.003,1,periods,assets); % NORMAL DIST
end

p = size(R,2); % ASSETS
n = size(R,1); % PERIODS

averet = mean(R,1); % AVERAGE ASSET RETURN, MEAN OVER ALL PERIODS
RCov   = cov(R);    % COVARIANCE MATRIX

% DETERMINE IF DENSE OR SPARSE.
if isempty(dense)
    density = nnz(RCov)/size(RCov,1)/size(RCov,2); % DENSITY OF MATRIX
    if density <= 0.33
        dense = 0;
    else
        dense = 1;
    end
end

if isempty(solver)
    solver = GetSolver('qp', ~dense); % SELECT SOLVER
end

if isempty(r_min)
    r_min = 0.001; %MINIMUM MEAN RETURN
else
    if length(r_min) ~=1
        error('r_min must be of length 1');
    end
end

% CHECKING OF MIN AND MAX FOR ASSETS

if isempty(w_max)
    w_max = ones(size(RCov,2),1)*inf;
else
    if length(w_max) ~= size(RCov,2)
        error('w_max is of incorrect length');
    end
    w_max = w_max(:);
end

if isempty(w_min)
    w_min = zeros(size(RCov,2),1);
else
    if length(w_min) ~= size(RCov,2)
        error('w_min is of incorrect length');
    end
    w_min = w_min(:);
end

% MODEL SELCTION, MODEL = 1 DEFAULT

if isempty(model)
    model = 1;
end

if isempty(Name)
    Name = 'FIN OPT';
end

if model == 2
    Q = spalloc(p+n,p+n,n);
    Q(p+1:p+n,p+1:p+n) = speye(n);
    A = [sparse(R) - repmat(sparse(averet),n,1); averet; ones(1,p)];
    A(1:n,p+1:p+n) = -1*speye(n);
    b_L = [zeros(n,1);r_min;1];
    b_U = [zeros(n,1);inf;1];
    w_min = [w_min; -inf*ones(p,1)];
    w_max = [w_max; inf*ones(p,1)];
    Prob = qpAssign(Q, [], A, b_L, b_U, w_min, w_max, [], Name);
    Prob.LargeScale = 1; % SELECT SPARSE SOLVER VERSION IF PRESENT
else
    A = [averet; ones(1,length(averet))];
    b_L = [r_min;1];
    b_U = [inf;1];
    Prob = qpAssign(RCov, [], A, b_L, b_U, w_min, w_max, [], Name);
    if ~dense
        Prob.LargeScale = 1;
    end
end

Result = tomRun(solver, Prob, [], PriLev);

if model == 1
    weights = Result.x_k(1:p);
else
    weights = Result.x_k(1:p);
end

% MODIFICATION LOG
%
% 041016  med  Created